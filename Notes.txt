SECTION 1
---------------------------------------------------------------------------------------------------------------------------------------------

Tech Stack for the E-Commerce Store built...
1. .Net Core Web API
2. React JS
3. Redux
4. TypeScript
5. SQLite DB
6. Entity Framework Core
---------------------------------------------------------------------------------------------------------------------------------------------

.NET Ecosystem

We generally use C# lang. which is converted to CLR using C# Runtime.
We will also use libaries and packeges (Nuget)
dotnet CLI to run and manage app.

What's a Web API ?
- HTTP based services on top of .NET
- Can be consumed by:
    - Browsers
    - Mobile Apps
    - IOT, etc.
- REST
    REST is a pattern for creating HTTP services.
    Its a set of protocol.
   Rules of REST are as follows:
    - It works on Client-Server architecture.
    - The communication must be stateless. Each request must be treated seperately and not return the cached response given of other client.
    - The response can be cacheable if server allows so that it can be used later by browser in re-rendering UI.
    - The interface for request and response should be uniform. It should not happen that one API is handled over HTTP and other is handled over some other protocol.

---------------------------------------------------------------------------------------------------------------------------------------------

Creating a .NET solution and API project

Go to cmd, direct to your folder
dotnet --info :  tells the latest version of .NET o our machine.
dotnet -h: gives list of commands (help)
dotnet new list : this command gives list of .NET projects we can create with current SDK
dotnet new sln : The template "Solution File" was created successfully.
dotnet new webapi -o API : creates a new We API project where its output folder is named "API"
dotnet sln add API : Project `API\API.csproj` added to the solution.
code . :This will open the ReStore folder in VS Code.
cd API: go to API folder.
dotnet run : runs the application on a port. http://localhost:5147/swagger/index.html

---------------------------------------------------------------------------------------------------------------------------------------------
VS Code Extensions needed for Dev

C#
C# Extensions
Nuget Gallery
Sqlite
Auto Rename Tag
After this, do >Reload Window from search bar above in VS Code,
Click yes to a pop-up which will give a .vscode folder
Then, turn "Auto Save" ON in "File" tab

---------------------------------------------------------------------------------------------------------------------------------------------

Adding Project to Github

Go to Source Control Icon on VS Code on left navigation
Click "Initialize Repository"
We'll see many files there
Go to terminal, type:
    dotnet new gitignore
This will ignore all .bin, .obj, ,vscode files etc which are not necessary.
Now, the number files to be uploaded will be reduced.

Also add appsettings.json to .gitignore by right clicking on it.
So that we will avoid publishing this to GitHub, in case we have any secret keys stored inside it.

---------------------------------------------------------------------------------------------------------------------------------------------

Inside Web API template.

Program.cs 
-----------
we can see that our app is built using WebApplication.CreateBuilder(args);
Our application runs on Kestrel web server.
The congiruations in Program.cs helps Kestrel in setting up the app.

We add dependamcy Injection in it.
Some services like controllers, Swagger are already registered in it.
We aso congure middlewares in it.

API.csproj
-------------
This tells the .NET target framework

Make the <nullable> as diabled,
otherwise we see errors while developing app. 
If it is enabled, it makes the "?" required for strings, throwing errors if not done so.
So disable it.

<ImplicitUsings>enable</ImplicitUsings>
This helps us to use certain buil-in libraries without sepcifyin them explicitly.
Use can see them in ~\Restore\API\obj\Debug\net7.0\API.GlobalUsings.g.cs

appSettings.json
-----------------
Update below:
"Microsoft.AspNetCore": "Information"
So that we get maximum information about endpoints we hit, info we received, etc.

---------------------------------------------------------------------------------------------------------------------------------------------

Entity Framework
-------------------
What is ? 

    In old days, when we had to do mapping between our entities/model and DB tables,
    Lets say, retrieve a list of products from Database,
    We need to:
        Open a connection to DB
        execute a command
        read data back from DB
        map data from DB to our entities/model
        remember to close the connection afterwards.

    With Entity Framework, 
        we do not need to do this anymore,
        Its job is to take our C# entity objects (Product obj. in our case)
        And it writes the SQL command for what we want to achieve ased on the code we write.
        So, we conitune to write our code in C#, we don't need to wite SQL Queries.
        EF is an Object Relational Mapper (ORM), which means it works with Relational Data and Relational DBs (SqlServer, Posgres, Oracle, SqlLite, etc).
    
    DbContext
    ----------
    We get a DbContext class from Entity framework.
    This provides us a gateway to our database or provides a session to our database.
    It's responsible for opening and managing connections to DB.

    DbSets
    -------
    DbContext can have one or more DbSets.
    These DbSets correspond to tables in our DB
    We use LINQ to query our data in methods inside DbSets

                LINQ                                    SQL
        -----------------------------> DbSets -----------------------> DB
        var products =                          select * from
            context.products.ToList()                   products


Features
--------
Modelling
    EF works with our objects, referred as Plain Old Class Objects (POCOs)
    That has get set properties and diff. data types 
Querying
    EF allows us to use LINQ queries.
Change Tracking
    EF tracks if anything is changed in DB
Saving
    It allows Saving our data in DB
Concurrency
    It will optimistically try and make changes in DB and if something goes wrong, it will be rolbacked.
Transactions
    Provides transaction management, we can build up a list of changes to be done in DB and all of that will go as a single transaction.
Caching
    For fast retrievals
Migrations
    Building DB and tables by looking st our code.

Configurations,
Built-in Conventions are also its features.
---------------------------------------------------------------------------------------------------------------------------------------------

To Use Entity Framework
------------------------
Install 
    EntityFrameworkCore.Sqlite
    EntityFrameworkCore.Design
of same version as that of dotnet on machine otherwise it won't work.

Create a Data Folder in API folder for all Data related classes
Create StoreConext class which extends DbContext (representing database)

Add a constructor which takes DbContextOptions as parameter by right Click

Add a DbSet as a property of type Product (representing table in our DB).

We need to inform our app about DbContext so register this service in Program.cs and 
inject the DbContextOptions in it
sepcifying, that we are using SqlLite and use the default connection string
Configure this def. conn. string in appsettings.Development.json.

---------------------------------------------------------------------------------------------------------------------------------------------

EF Migrations
------------
Go to : https://www.nuget.org/packages/dotnet-ef
Install dotnetef via CLI    
    dotnet tool install --global dotnet-ef --version 7.0.13
    (Version same as dotnet on my machine)

Stop the app if its already running
Go to CLI and type:
    dotnet ef migrations add InitialCreate -o Data/Migrations
After successful completion,
we see Migrations folder is created with 3 cs files in it.

We are interested in TimeStamp_InitialCreate.cs
Here, it is representing Product.cs in form of SqlLite table
Up() fo creating Products table and Down() for dropping.

Go to CLI:
    dotnet ef database update
This command will create a db file (database) based on InitialCreate.cs
We can see "store.db" file in our Folder structure.
Can't open it, go to search bar in VS Code and type:
    >sqlite:Open Database
        Select Database
        We see new panel added "SqLite Explorer" in Left Navigation bar in VSCode

Open store.db under Sqlite Explorer
We see Products table (empty)
and _EFMigrationsHistory table (having last update time and version)
---------------------------------------------------------------------------------------------------------------------------------------------

Initialize Products Table 
---------------------------

Go to Data Folder, Create a static class DbInitializer
Create a static method Initialize(StoreConext context)
Add dummy data in it, ONLY if our table is empty.
List of products given in Course Assets of 
https://persistent.udemy.com/course/learn-to-build-an-e-commerce-store-with-dotnet-react-redux/learn/lecture/28964732#overview
ProductSeed.txt

Add that dummy data inside Products DbSet
And Save changes

---------------------------------------------------------------------------------------------------------------------------------------------

Perform Migration and DB Initialization
-----------------------------------------

We can Perform Migration and DB Initialization automaticaly when App runs via Program.cs
Just before app.run

We can create a scope variable to take hold of StoreConext
and ILogger for logging
And Perform migrations and DB Initialization

To see the effects, got to CLI and drop the store.db
    dotnet ef database drop
    press y
The store.db is dropped.
Add the above steps mentioned inside Program.cs
And do dotnet run
We see in CLI, all the rows being added in Products table
Go to store.db by again adding SQLite Explorer from VS Code and selecting our db
Run products table, we see all rows added.

---------------------------------------------------------------------------------------------------------------------------------------------

Creating API Controllers to Get Products
---------------------------------------------

Go to Controllers folder,
add ProductsController.cs same as WeatherForecasetController by right click and select ApiController
Add StoreContext via Dependency Injection

Create two ActionResult Methods/ APIs
GetProducts()
GetProduct(id)
Run the app (dotnet run) and check on Swagger.

---------------------------------------------------------------------------------------------------------------------------------------------

Make APIs Asynchronous
-------------------------
For small scale applications, it is Ok to query list of products directly from DB.
When data is small or no. of users are less, we see no problem.

But as the system starts scaling, data size becomes huge and load increases.
Servers will keep the users waiting when they request for certain data.
In such cases, we should not keep the user waiting and make the calls asynchronous.

So that it will execute the rest of code and notify the caller, when response is ready.
this can be done using async await.
This prevents blocking of main thread.
We use Task<> as wrapper around return types in async await functions
---------------------------------------------------------------------------------------------------------------------------------------------


SECTION 2
---------------------------------------------------------------------------------------------------------------------------------------------

Creating React App
-------------------
Instead of traditional creat-react-app, we will use Vite
Go to Restore folder, open CLI  
    npm create vite@latest
    y
    Proj Name: client
    Select Framework: React
    Select Variant: TypeScript + SWC (Speedy Web Compiler)
    cd client
    npm install
    npm run dev

Changed Port No to 3000
and start: vite
Now, npm start will launch the client app on port 3000
---------------------------------------------------------------------------------------------------------------------------------------------

UseState
-------------
React UseState is a hook in react, which acts as a memory store.
We can use classes and objects in JS to do so, but it is pretty complex.
So, with functional components we use certain hooks.
useState is a hook, which keeps track of values stored in any variable
It provides a setXXX function for setting new value to state variable.

UseEffect
---------------
React UseEffect hook allows us to add a side-effect to a component whe it loads.
In react when component loads, we get access to its lifecycle.
What to do when component mounts and when destroyed.

In our example, we initialized "products" in App.tsx by fetching data from backend.
For that, our dotnet web api must be running.
    dotnet run
Then inside useEffect, we resolved promises and called setProducts to initialize data.
We also passed an empty Dependency Array, so that we fetch data only once when component loads.

But on doing 
    npm start
And check console in browser, we get following error:
        Access to fetch at 'http://localhost:5000/api/products' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 
        If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.

We see, in networks tab (preserve log and reload again)
2 requests were made to backend to fetch products.
This was because of 
     <React.StrictMode>
     </React.StrictMode> tags, 
React tries its best to protect us from making mistake in our code. Its a normal behaviour.
----------
CORS
-----------
Now coming back to main problem, we got the error as stated above, inside our console and
We could not data from our backend.
This is because our origin of request is from localhost:3000
and response is from localhost:5000
So we are requesting data from different domain. Hence, our browser is protecting us.

Cross-origin resource sharing (CORS) is a mechanism for integrating applications. 
CORS defines a way for client web applications that are loaded in one domain to interact with resources in a different domain.

So to solve this problem,
we need to enable CORS in our "API" (backend app).

So, going back to Program.cs, 
we need to add a Service 
    builder.Services.AddCors();

and Middleware, just above UseAuthorization()
    app.UseCors(opt => {
    opt.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:3000");
});

Now, we get response from backend and we render in our frontend.
---------------------------------------------------------------------------------------------------------------------------------------------

Creating TypeScript Interface
------------------------------
Create a new file, Product.ts (this is an interface)

Go to: http://localhost:5000/swagger/index.html
And take the response received and paste at https://transform.tools/json-to-typescript
And copy the typescript generated and paste in the interface.
This will avoid any spelling and data type mistakes.

Now, in useState, we need to specify that products State is of type Product.ts
We do so, by adding <Product[]>
This tells useState tht the products, is an array of type Product.ts

Now, we also need to midift addProducts() method, as all properties of interface are required
We can mark any field as optional by adding '?' in Interface property
    quantityInStock?: number

---------------------------------------------------------------------------------------------------------------------------------------------

Files and Folder Organisation
------------------------------
create an "app" folder in src, to store everything related to our app.
inside "app" create "layout" folder and add App.tsx and styles.css and say yes to all popups of VS Code

Create "models" folder in "app" folder to store Product.ts and all such domain contacts in it.

Create "features" in "src" to add  all new components in it.
---------------------------------------------------------------------------------------------------------------------------------------------

Create Catalog component
-------------------------------
Add catalog.tsx in features folder,
Pass products as props. Render the unordered list and addproducts button inside catalog.tsx

The props can be marked of type : Any - but we loose the benefits of typecript here.
So we will create an interface in Catalog.tsx for props.
And specify, what we can get as props and what its type can be.
We also get all the intellisense, if we hover over all objects.
So whenever <Catalog /> is used somewhere, we will get an error stating that we need to pass products array and addProduct method to it.

instead of using props. everywhere as a suffix in Catalog.tsx
We can use destructuring {..,..} to spcify what properties we are interested in, from Props interface.
So we do not need to add props. as suffix everywhere down.

---------------------------------------------------------------------------------------------------------------------------------------------

Adding Material UI (styling framework)
------------------------------------------

Go to : https://mui.com/material-ui/getting-started/installation/
And install as given inside client folder:
    Default Installation
        npm install @mui/material @emotion/react @emotion/styled

    Font Install
        npm install @fontsource/roboto
        Then import fonts in index.tsx as given in documentation
Then again in CLI for icons
    Icons Install
        npm install @mui/icons-material

Use <Typography>, <List>, <Button> as given in Docs of metrial UI

---------------------------------------------------------------------------------------------------------------------------------------------

Add seperate components for ProductList and ProductCard
-------------------------------------------------
Rendering all products in a list called ProductList.
Where each list item is a ProductCard.
