---------------------------------------------------------------------------------------------------------------------------------------------
                                            SECTION 1 - Building Backend
---------------------------------------------------------------------------------------------------------------------------------------------

Tech Stack for the E-Commerce Store built...
1. .Net Core Web API
2. React JS
3. Redux
4. TypeScript
5. SQLite DB
6. Entity Framework Core
---------------------------------------------------------------------------------------------------------------------------------------------

.NET Ecosystem

We generally use C# lang. which is converted to CLR using C# Runtime.
We will also use libaries and packeges (Nuget)
dotnet CLI to run and manage app.

What's a Web API ?
- HTTP based services on top of .NET
- Can be consumed by:
    - Browsers
    - Mobile Apps
    - IOT, etc.
- REST
    REST is a pattern for creating HTTP services.
    Its a set of protocol.
   Rules of REST are as follows:
    - It works on Client-Server architecture.
    - The communication must be stateless. Each request must be treated seperately and not return the cached response given of other client.
    - The response can be cacheable if server allows so that it can be used later by browser in re-rendering UI.
    - The interface for request and response should be uniform. It should not happen that one API is handled over HTTP and other is handled over some other protocol.

---------------------------------------------------------------------------------------------------------------------------------------------

Creating a .NET solution and API project

Go to cmd, direct to your folder
dotnet --info :  tells the latest version of .NET o our machine.
dotnet -h: gives list of commands (help)
dotnet new list : this command gives list of .NET projects we can create with current SDK
dotnet new sln : The template "Solution File" was created successfully.
dotnet new webapi -o API : creates a new We API project where its output folder is named "API"
dotnet sln add API : Project `API\API.csproj` added to the solution.
code . :This will open the ReStore folder in VS Code.
cd API: go to API folder.
dotnet run : runs the application on a port. http://localhost:5147/swagger/index.html

---------------------------------------------------------------------------------------------------------------------------------------------
VS Code Extensions needed for Dev

C#
C# Extensions
Nuget Gallery
Sqlite
Auto Rename Tag
After this, do >Reload Window from search bar above in VS Code,
Click yes to a pop-up which will give a .vscode folder
Then, turn "Auto Save" ON in "File" tab

---------------------------------------------------------------------------------------------------------------------------------------------

Adding Project to Github

Go to Source Control Icon on VS Code on left navigation
Click "Initialize Repository"
We'll see many files there
Go to terminal, type:
    dotnet new gitignore
This will ignore all .bin, .obj, ,vscode files etc which are not necessary.
Now, the number files to be uploaded will be reduced.

Also add appsettings.json to .gitignore by right clicking on it.
So that we will avoid publishing this to GitHub, in case we have any secret keys stored inside it.

---------------------------------------------------------------------------------------------------------------------------------------------

Inside Web API template.

Program.cs 
-----------
we can see that our app is built using WebApplication.CreateBuilder(args);
Our application runs on Kestrel web server.
The congiruations in Program.cs helps Kestrel in setting up the app.

We add dependamcy Injection in it.
Some services like controllers, Swagger are already registered in it.
We aso congure middlewares in it.

API.csproj
-------------
This tells the .NET target framework

Make the <nullable> as diabled,
otherwise we see errors while developing app. 
If it is enabled, it makes the "?" required for strings, throwing errors if not done so.
So disable it.

<ImplicitUsings>enable</ImplicitUsings>
This helps us to use certain buil-in libraries without sepcifyin them explicitly.
Use can see them in ~\Restore\API\obj\Debug\net7.0\API.GlobalUsings.g.cs

appSettings.json
-----------------
Update below:
"Microsoft.AspNetCore": "Information"
So that we get maximum information about endpoints we hit, info we received, etc.

---------------------------------------------------------------------------------------------------------------------------------------------

Entity Framework
-------------------
What is ? 

    In old days, when we had to do mapping between our entities/model and DB tables,
    Lets say, retrieve a list of products from Database,
    We need to:
        Open a connection to DB
        execute a command
        read data back from DB
        map data from DB to our entities/model
        remember to close the connection afterwards.

    With Entity Framework, 
        we do not need to do this anymore,
        Its job is to take our C# entity objects (Product obj. in our case)
        And it writes the SQL command for what we want to achieve ased on the code we write.
        So, we conitune to write our code in C#, we don't need to wite SQL Queries.
        EF is an Object Relational Mapper (ORM), which means it works with Relational Data and Relational DBs (SqlServer, Posgres, Oracle, SqlLite, etc).
    
    DbContext
    ----------
    We get a DbContext class from Entity framework.
    This provides us a gateway to our database or provides a session to our database.
    It's responsible for opening and managing connections to DB.

    DbSets
    -------
    DbContext can have one or more DbSets.
    These DbSets correspond to tables in our DB
    We use LINQ to query our data in methods inside DbSets

                LINQ                                    SQL
        -----------------------------> DbSets -----------------------> DB
        var products =                          select * from
            context.products.ToList()                   products


Features
--------
Modelling
    EF works with our objects, referred as Plain Old Class Objects (POCOs)
    That has get set properties and diff. data types 
Querying
    EF allows us to use LINQ queries.
Change Tracking
    EF tracks if anything is changed in DB
Saving
    It allows Saving our data in DB
Concurrency
    It will optimistically try and make changes in DB and if something goes wrong, it will be rolbacked.
Transactions
    Provides transaction management, we can build up a list of changes to be done in DB and all of that will go as a single transaction.
Caching
    For fast retrievals
Migrations
    Building DB and tables by looking st our code.

Configurations,
Built-in Conventions are also its features.
---------------------------------------------------------------------------------------------------------------------------------------------

To Use Entity Framework
------------------------
Install 
    EntityFrameworkCore.Sqlite
    EntityFrameworkCore.Design
of same version as that of dotnet on machine otherwise it won't work.

Create a Data Folder in API folder for all Data related classes
Create StoreConext class which extends DbContext (representing database)

Add a constructor which takes DbContextOptions as parameter by right Click

Add a DbSet as a property of type Product (representing table in our DB).

We need to inform our app about DbContext so register this service in Program.cs and 
inject the DbContextOptions in it
sepcifying, that we are using SqlLite and use the default connection string
Configure this def. conn. string in appsettings.Development.json.

---------------------------------------------------------------------------------------------------------------------------------------------

EF Migrations
------------
Go to : https://www.nuget.org/packages/dotnet-ef
Install dotnetef via CLI    
    dotnet tool install --global dotnet-ef --version 7.0.13
    (Version same as dotnet on my machine)

Stop the app if its already running
Go to CLI and type:
    dotnet ef migrations add InitialCreate -o Data/Migrations
After successful completion,
we see Migrations folder is created with 3 cs files in it.

We are interested in TimeStamp_InitialCreate.cs
Here, it is representing Product.cs in form of SqlLite table
Up() fo creating Products table and Down() for dropping.

Go to CLI:
    dotnet ef database update
This command will create a db file (database) based on InitialCreate.cs
We can see "store.db" file in our Folder structure.
Can't open it, go to search bar in VS Code and type:
    >sqlite:Open Database
        Select Database
        We see new panel added "SqLite Explorer" in Left Navigation bar in VSCode

Open store.db under Sqlite Explorer
We see Products table (empty)
and _EFMigrationsHistory table (having last update time and version)
---------------------------------------------------------------------------------------------------------------------------------------------

Initialize Products Table 
---------------------------

Go to Data Folder, Create a static class DbInitializer
Create a static method Initialize(StoreConext context)
Add dummy data in it, ONLY if our table is empty.
List of products given in Course Assets of 
https://persistent.udemy.com/course/learn-to-build-an-e-commerce-store-with-dotnet-react-redux/learn/lecture/28964732#overview
ProductSeed.txt

Add that dummy data inside Products DbSet
And Save changes

---------------------------------------------------------------------------------------------------------------------------------------------

Perform Migration and DB Initialization
-----------------------------------------

We can Perform Migration and DB Initialization automaticaly when App runs via Program.cs
Just before app.run

We can create a scope variable to take hold of StoreConext
and ILogger for logging
And Perform migrations and DB Initialization

To see the effects, got to CLI and drop the store.db
    dotnet ef database drop
    press y
The store.db is dropped.
Add the above steps mentioned inside Program.cs
And do dotnet run
We see in CLI, all the rows being added in Products table
Go to store.db by again adding SQLite Explorer from VS Code and selecting our db
Run products table, we see all rows added.

---------------------------------------------------------------------------------------------------------------------------------------------

Creating API Controllers to Get Products
---------------------------------------------

Go to Controllers folder,
add ProductsController.cs same as WeatherForecasetController by right click and select ApiController
Add StoreContext via Dependency Injection

Create two ActionResult Methods/ APIs
GetProducts()
GetProduct(id)
Run the app (dotnet run) and check on Swagger.

---------------------------------------------------------------------------------------------------------------------------------------------

Make APIs Asynchronous
-------------------------
For small scale applications, it is Ok to query list of products directly from DB.
When data is small or no. of users are less, we see no problem.

But as the system starts scaling, data size becomes huge and load increases.
Servers will keep the users waiting when they request for certain data.
In such cases, we should not keep the user waiting and make the calls asynchronous.

So that it will execute the rest of code and notify the caller, when response is ready.
this can be done using async await.
This prevents blocking of main thread.
We use Task<> as wrapper around return types in async await functions
---------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------
                                            SECTION 2 - Building Frontend
---------------------------------------------------------------------------------------------------------------------------------------------

Creating React App
-------------------
Instead of traditional creat-react-app, we will use Vite
Go to Restore folder, open CLI  
    npm create vite@latest
    y
    Proj Name: client
    Select Framework: React
    Select Variant: TypeScript + SWC (Speedy Web Compiler)
    cd client
    npm install
    npm run dev

Changed Port No to 3000
and start: vite
Now, npm start will launch the client app on port 3000
---------------------------------------------------------------------------------------------------------------------------------------------

UseState
-------------
React UseState is a hook in react, which acts as a memory store.
We can use classes and objects in JS to do so, but it is pretty complex.
So, with functional components we use certain hooks.
useState is a hook, which keeps track of values stored in any variable
It provides a setXXX function for setting new value to state variable.

UseEffect
---------------
React UseEffect hook allows us to add a side-effect to a component whe it loads.
In react when component loads, we get access to its lifecycle.
What to do when component mounts and when destroyed.

In our example, we initialized "products" in App.tsx by fetching data from backend.
For that, our dotnet web api must be running.
    dotnet run
Then inside useEffect, we resolved promises and called setProducts to initialize data.
We also passed an empty Dependency Array, so that we fetch data only once when component loads.

But on doing 
    npm start
And check console in browser, we get following error:
        Access to fetch at 'http://localhost:5000/api/products' from origin 'http://localhost:3000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. 
        If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.

We see, in networks tab (preserve log and reload again)
2 requests were made to backend to fetch products.
This was because of 
     <React.StrictMode>
     </React.StrictMode> tags, 
React tries its best to protect us from making mistake in our code. Its a normal behaviour.
----------
CORS
-----------
Now coming back to main problem, we got the error as stated above, inside our console and
We could not data from our backend.
This is because our origin of request is from localhost:3000
and response is from localhost:5000
So we are requesting data from different domain. Hence, our browser is protecting us.

Cross-origin resource sharing (CORS) is a mechanism for integrating applications. 
CORS defines a way for client web applications that are loaded in one domain to interact with resources in a different domain.

So to solve this problem,
we need to enable CORS in our "API" (backend app).

So, going back to Program.cs, 
we need to add a Service 
    builder.Services.AddCors();

and Middleware, just above UseAuthorization()
    app.UseCors(opt => {
    opt.AllowAnyHeader().AllowAnyMethod().WithOrigins("http://localhost:3000");
});

Now, we get response from backend and we render in our frontend.
---------------------------------------------------------------------------------------------------------------------------------------------

Creating TypeScript Interface
------------------------------
Create a new file, Product.ts (this is an interface)

Go to: http://localhost:5000/swagger/index.html
And take the response received and paste at https://transform.tools/json-to-typescript
And copy the typescript generated and paste in the interface.
This will avoid any spelling and data type mistakes.

Now, in useState, we need to specify that products State is of type Product.ts
We do so, by adding <Product[]>
This tells useState tht the products, is an array of type Product.ts

Now, we also need to midift addProducts() method, as all properties of interface are required
We can mark any field as optional by adding '?' in Interface property
    quantityInStock?: number

---------------------------------------------------------------------------------------------------------------------------------------------

Files and Folder Organisation
------------------------------
create an "app" folder in src, to store everything related to our app.
inside "app" create "layout" folder and add App.tsx and styles.css and say yes to all popups of VS Code

Create "models" folder in "app" folder to store Product.ts and all such domain contacts in it.

Create "features" in "src" to add  all new components in it.
---------------------------------------------------------------------------------------------------------------------------------------------

Create Catalog component
-------------------------------
Add catalog.tsx in features folder,
Pass products as props. Render the unordered list and addproducts button inside catalog.tsx

The props can be marked of type : Any - but we loose the benefits of typecript here.
So we will create an interface in Catalog.tsx for props.
And specify, what we can get as props and what its type can be.
We also get all the intellisense, if we hover over all objects.
So whenever <Catalog /> is used somewhere, we will get an error stating that we need to pass products array and addProduct method to it.

instead of using props. everywhere as a suffix in Catalog.tsx
We can use destructuring {..,..} to spcify what properties we are interested in, from Props interface.
So we do not need to add props. as suffix everywhere down.

---------------------------------------------------------------------------------------------------------------------------------------------

Adding Material UI (styling framework)
------------------------------------------

Go to : https://mui.com/material-ui/getting-started/installation/
And install as given inside client folder:
    Default Installation
        npm install @mui/material @emotion/react @emotion/styled

    Font Install
        npm install @fontsource/roboto
        Then import fonts in index.tsx as given in documentation
Then again in CLI for icons
    Icons Install
        npm install @mui/icons-material

Use <Typography>, <List>, <Button> as given in Docs of metrial UI

---------------------------------------------------------------------------------------------------------------------------------------------

Add seperate components for ProductList and ProductCard
-----------------------------------------------------
Rendering all products in a list called ProductList.
Where each list item is a ProductCard.

Create an AppBar from Material UI
create Header.tsx in layout folder.

Make productCard look like a Card from Material Ui


Using Dark Mode
-------------------
W can do so, by createTheme provided by Material UI
which automatically sets the correct dark mode color for existing colors used in App.
Using Switch component of Material Ui to add a toggle button.

---------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------
                                            SECTION 3 - Navigation via React Router and using Axios
---------------------------------------------------------------------------------------------------------------------------------------------

Now, we will use 
    React-Router
        In older days, whenever we cliked a link to go to next page.
        We used to visit a new HTML web page.
        Even the navbar had to be loaded again for each page.
        Nowadays, we use Single Page Application (SPA) technologies like React and Angular.
        So only certain components get loaded on performing any action.
        To go through these components, we use React-Router for routing.
        Can be used with React JS or React Native both.

    Axios
        Its an HTTP Client
        Its basically an easy and powerful replacement of fetch API.
        Offer imilar functionality to Angular HTTP Client.
        It can intercep requests and response.
-----------------------------------------------------------------------------------------------
React Router Install via CLI in Clinet folder
        npm install react-router-dom

Create folders and files for Home, Contact, About and ProductDetails in features folder


Create router -> Routes.tsx in app folder.
here, we specify all the possible routes in app.
    '/' routes to basic component -> <App />
    and all other elements are mentioned in children array,
    These will be loaded, as per the path specified, on top of parent, <App />

In index.tsx, we load <App /> via <RouterProvider> 
For each children element in <App />, we use <outlet/> //see the comments in code
-----------------------------------------------------------------------------------------------

Add Navigation links in App Bar

Create an array of Navigation links
And use map() function inside <List> to iterate over them.
To render these ListItems as navigation links
pass NavLink (belonging to rect-router) as 'component' prop in ListItem tag.
the 'to' prop is mandatory, so specify path in it.

Add a shopping cart icon between midLinks and rightLinks

Make company logo route to home page.

Add styling to navbar links
Group different elements in Box for styling
-----------------------------------------------------------------------------------------------

UseParams hook
-------------------
useParams is a hook provided by react-router.
That helps in capturing the url details.
In out case, product id.

useEffect for fetching product each time when id changes, hence added  id in Dependency Array.
Fetched data via axios and not traditional fetch API

Did some basic error handling when product not found.

Created UI for ProductDetails Page using Material UI attributes.

---------------------------------------------------------------------------------------------------------------------------------------------
                                            SECTION 4 - Error Handling
---------------------------------------------------------------------------------------------------------------------------------------------

First of All, in Controller folder in API
We will create a BaseApiController as parent class, to avoid writing
redundant code and follow DRY principle.

Added a BuggyController classWhich will return us 
all possible types of errors from Backend.
Tested them on Swagger to see the response.

Create a custom middleware to perform Exception Handling on backend.
In the constructor add 
    RequestDelegate (to pass on to next piece of middleware)
    ILogger (to log details)
    HostEnvironment (to check the environment)
Create InvokeAsync() method,
    Call _next() if all good
    else catch the exception and send it as jsonResponse

Put this middleware at top in Program.cs

Now check, server-error endpoint on swagger.
Now any exception thrown by backend is passed as a jsonResponse in neat way, like other responses.
---------------------------------------------------------------------------------------------------------------------------------------------

Centralizing all Axios Requests at one place.
-----------------------------------------------
Axios has a powerful feature called interceptor.
So it manipulate requests and response.
Hence it has an edge over fetch() API

So, we will now write cleaner axios queries everywhere, by centralizing axios at one place.

Create api->"agent.ts" in API folder.
use axios object
    Add baseURL
    Render response as json 
    create get, pu, post, delete queries, with paramaters

Create a Catalog object and mention all kinds of requests it makes.

Create an agent object, add Catalog in it.

Now we can replace Axios calls in Product Details and fetch() in Catalog.tsx
by the agent, to make code more cleaner.
---------------------------------------------------------------------------------------------------------------------------------------------

Create Axios requests to hit BuggyController endpoints in agent.ts
Use About Page, to test these errors
    Open Network Tab beside console
    Look at Preview when you click on any of the test button.

Currently in ProductDetails,
If we send a wrong productId, we get 204 No Content Error
Instead we should get 404 not found error.
Actually, in backend, we are not checking for null. We must return NotFound() if we get null response from DbContext.
After correcting this,
And making wrong id call, we see 404 error in console.
---------------------------------------------------------------------------------------------------------------------------------------------
Axios Interceptors cn be used to catch the errors coming from response
Instead of showing a red error in console.
We can Catch the error by
    returning Promise.reject(error.response)

So wherever we catch error like in ProductDetails or AboutPage (Test buttons),
    if we just console.log(error), 
        "Error caught by Interceptor" &
        we wll see error.response.
---------------------------------------------------------------------------------------------------------------------------------------------

Install React-Toastify.
To show toast notifications
Now in axios interceptor in agent.ts
    we can show errors as toast notifications.
So in any feature if we catch error
Will will also get toast notification.

Validation Errors also throw 400 status code.
So handle them in case 400, inside switch case block in agent.ts interceptors to throw list of errors

catch the array of errors in About Page in a state.
If errors received, show them with <Alert> of material ui
---------------------------------------------------------------------------------------------------------------------------------------------
Debugging in ASP.NET Core in VS Code

Click Run and Debug option in leftmost bar.
We have two options 
.NET Core launch(web) -  to go in debug mode as soon as app launches (required to debug Program.cs).
.NET Core Attach - to attach  when app is already running

Click Run button
Select our backend app -> API.exe 
Now we are in debug mode.

For a react app:
Just using the "debugger;" word anywhere in code
Will add a breakpoint.
Go to Inspect -> Sources (beside console) -> We see our code stops at that line
We get options to Step Over and Step In

Linting
-------------
Linting is the automated checking of your source code for programmatic and stylistic errors.
In React we can see potential errors by closing the frontend, going to CLI, run: 
    npm run lint
This gave us 2 errors
  \src\app\api\agent.ts
1.  55:38  error  Don't use `{}` as a type. `{}` actually means "any non-nullish value".
2. 56:37  error  Don't use `{}` as a type. `{}` actually means "any non-nullish value".

But we want the VS Code to tell these errors as soon as we type them.
So for that we can download an extension of "ESLint" by Microsoft.
Now, this notifies us errors in any file.
Even if we skip Dependency array for useEffect by using return statement, it will notify us.

---------------------------------------------------------------------------------------------------------------------------------------------
                                            SECTION 5 - Shopping Cart
---------------------------------------------------------------------------------------------------------------------------------------------

Lets Create The Basket Entity
and BasketItem to store baskets on server.

We donot need to explicitly mention BasketItem DbSet as we are not going to query it.
Go to CLI
    dotnet ef migrations add BasketEntityAdded

We are not happy with migration so run 
    dotnet ef migrations remove

In migration created just now, even if we deleted a basket, basket items were retained in DB.
And BasketItem was name of table created automatically, we wanted plural name.

So to achieve this,
1. We add extra navigation properties in BasketItem 
    BasketId 
    Basket
    to define relation at both sides
2. Use Data Annotation to pluralise name of table.
    [Table("BasketItems")]

If we now check the migration, we see
    name: "FK_BasketItems_Baskets_BasketId",
    onDelete: ReferentialAction.Cascade
It means, if we delete a basket, it will also delete a basketItem

     name: "FK_BasketItems_Products_ProductId",
     onDelete: ReferentialAction.Cascade
It means, if we delete a product, that will also delete the basket Item.

Once we are satisfied with our migration, we run
    dotnet run

Search:
    >Sqlite - Open Database
    In above search bar
And check that tables added.

---------------------------------------------------------------------------------------------------------------------------------------------

Open Swagger, make a post request, debug line by line.
And check the changes that happen.
At the end, go to browser, go to Inspect -> Application -> Cookies
We see a cookie added for buyerId with a new Guid.
Also, the same data is stored in Basket table in store.db

But when we try to GetBasket() after this, we get an internal server error.
Why?
    Error had come from the Json Serializer.
    Its telling us that possible object cycle was detected.
    Our API Controller tries to generate a JsonResponse.
    It takes a look at the objects its trying to return and try to format that to JSON.

    But if we take a look at Basket class.
    We have list of BasketItems
    and in BasketItem class, we have reference to product and basket.
    Lets consider, this navigation property Basket. It tries to serialze basket
    But, This basket has BasketItems internally, it tries to serialize basketItems list again,
    But this BasketItem has reference to basket, so it keeps on serialaizing in an endless loop.
    Similarly for Product.

But, we do not want to return an entity, we need to shape the data, we wish to return.
When we return Basket Item, we weish to know the details of product in it, not the Product as an object.
So we will create some objects, that will shape our data we wish to return.

These type of objects are referred to as DTOs (Data Transfer Objects)
These are simple plain objects that contain properties that we want to extract from our entities and return with our response.

So we create BasketDTO and BasketItemDTO
In GetBasket(),
    We will return BasketDTO
    Where basketItemDTO properties will be filled, based on basket retrieved from _context.

---------------------------------------------------------------------------------------------------------------------------------------------

Currently, we are not sending the Staus 201 right way.
According to MDN docs, we must send 201 when a resource is created and send the newly created resource along with Response.
But sometimes, we might be just updating quantity in our case.

So we will use, CreatedAtRoute(location_To_Get_This_Rsource, resoure_Newly_Created) method
Note: 
    location: http://localhost:5000/api/Basket 
    added in response header, as we specified the URL from where we can fetch the resource generated

---------------------------------------------------------------------------------------------------------------------------------------------
Also, now if we lok at our Cookie.
Currently we are testing on same domain, localhost:5000,
hence we have no issue of CORS and we can easily pass cookie back and forth.

But our React app, is on different domain. localhost:3000,
In that case, we need to explicitly mention to allow passing of cookies across domains
by adding AllowCredentials() method in UseCors() middleware.
---------------------------------------------------------------------------------------------------------------------------------------------

On Client Side, 
we will add the API calls for axios in agent.ts and export them.
Go to ProductCard file and create a handleAddItem() function to give call to addItem
Also set loading till we add in the item.

Not to set loading button from material-ui, we need to use it, from its lab,
for that go to CLI
    npm install @mui/lab @mui/material

Now before testing, the add functionality, make sure to delete the cookie.
Check, the network tab before pressing Add Item button, youbwill notice what response we get
and a new buyerId cookie stored in Application tab.
---------------------------------------------------------------------------------------------------------------------------------------------

Basket component
Now to create a basket component, we need to know the shape of Basket object
Go to swagger, copy object from Get request and paste in https://transform.tools/json-to-typescript
And generate a model class accordingly.

Add a new folder in features => basket
Create BasketPage.tsx
Add new route in Router.tsx
Link that to Shopping Cart Icon
---------------------------------------------------------------------------------------------------------------------------------------------

Now, we need to update the number present in shopping cart Icon,
But for that, we need the access of our basket items.
But Basket Items are set inside the BasketPage.
But Basket Page and shopping Cart Ison are 2 different components.
I want to increment basket count from Catalog component as well.
as soon as I add any item to basket.

How to exchange this data between completely different components?
For that, we created StoreContext using useContext hook of react.

Anything mentioned in Context API can be accessed globally, by any component.
In Context API, we store states, functions to make accessible globally.


---------------------------------------------------------------------------------------------------------------------------------------------
                                            SECTION 6 - Redux
---------------------------------------------------------------------------------------------------------------------------------------------
Redux: 
    Javascript library that provides state mangement for our application.
    Its for any type of Application, React, Angular, Vue
    React-Redux - allows us to integrate Redux in our app easily and manage states in our app.
    Redux-Toolkit - To help us write redux code.
    Redux-DevTools - for troubleshooting problems in app.

Redux-Store
    Redux is like store for our app, which stores states for our app in a centralized location.
    We can have, one store per app.
    Each store contains many reducers or slices of state.

When we use Redux, we will create a Provider.
Which provides states of our application, similar to useContext() but more powerful.

Flow of Redux:
        1.Store - ontains all states at central place.
        2.Provider - we provide all states in store, to Reduc-Provider.
        3.App - The provider provides the states to entire app.
        4. Components - From app, those states can be passed down to all components.
        5. Actions - Whenever a component wants to change any state, it uses something called Actions.
        6. Reducers - Reducer function are responsible to change states in store depending on action coming as input and current state.
        8. Store - When state updated in app, step 1 to 7 is again follwed to notify the updation of state.

Redux Bes Practices
1. Do not mutate states inside Redux Store.
   We should create a new state and replace that with existing state.

2. Reducers must not have side effects - they should not go and fetch data from somewhere.

3. Do not have non-serialaizable values in States or Actions - not to use class instances or funtions in states.

4. Only 1 store per app.

Redux Toolkit helps to stick to these best practices.
It has good defaults for store setup.
It has most common built-ins.
Less boilerplate code.


To use Redux, go to CLI in client folder
    npm install redux react-redux

If we look at the example created till now.
We had to write a lot of boilerplate code, to do a small thing.

Hence to reduce this effor, we will use Redux - Toolkit, go to CLI in client folder.
    npm install @reduxjs/toolkit

Redux DevTools is a Chrome Extension that helps in debugging Redux code.
---------------------------------------------------------------------------------------------------------------------------------------------

Creating a basket slice/reducer
--------------------------
Added initialState
Added reducers similar to StoreConext
exported actions.

Replaced StreContext with basketSlice everywhere.
---------------------------------------------------------------------------------------------------------------------------------------------

At this point, we will centralize all the Api calls made to set and remove basket items at one plce.
Using Redux's createThunkAsync method.
And remove all repeated code from every page.

Now when we click on Add To Cart on any item
All "Add To Cart" buttons for all cards are going in loading state.
To solve this, we can add a productId in from of pending statusWhich will specify, exactly which 
Add To Cart / Product is in pending state before being added to basket.
And depending on this productId, we can add loadingbutton true to that specific product.

Creating a removeItem centralized call using thunk.
Adding return type as void, since, we do not get anything from backend, when we remove an item.
Use RemoveItem in all places and centralize the api call

---------------------------------------------------------------------------------------------------------------------------------------------

Createed a fetchProductAsync and fetchProductsAsync
To centralise the cll of fetching product from API.
We also avoided fetching product from backend, by using Entity Adapters.
So that, when app is loaded,
Our Products array is filled (productsAdapter)

So after that, when we View any product, we do not see loading symbol, since we fetched it from productAdapters.
We will fetch that product from backend, only if necessary.

Performed error handling, using thunkAPI
and return error.data in catch block in catalog.slice.

Also fixed the loading button issue in ProductDetailsPage

Read again about useContext and Redux, Thunk, etc.

---------------------------------------------------------------------------------------------------------------------------------------------
                                        SECTION 7 - Paging, Sorting, Searching, Filtering
---------------------------------------------------------------------------------------------------------------------------------------------

First, 
we created an extensions folder in API folder.
Here, we wrote our custom Sort( ) method for IQueryable<Products> 
where, we fetch the poducts from DB with ORDER BY clause.
ORDER BY
    Name (default)
    Price
    Price Descending

An IQueryable is not actually a collection of entities, 
rather it describes how to obtain that collection. 
The data is never retrieved from the source until you evaluate it, by turning it into an IEnumerable or IList.

The advantage of returning an IQueryable from your repository is that 
your calling code can specify additional .Where clauses BEFORE the query goes to the database. 
If you returned an IEnumerable, your code would retrieve all values of one table from the database, and then perform filtering in memory, which is inefficient.

At this point, we create a custom Search method to search in Product Names
Based on search term.
So now, we ca sor and search together, check on swagger.

At this point, we added Filter method To filter products based on 
multiple brands and types seperated in comma seperated values.
If our brands or types do not match, we return an empty list

Now we can do Sort(), Search(), Filter() all at once.
Check on Swagger.

This is how query is created 
Ex:
    SELECT "p"."Id", "p"."Brand", "p"."Description", "p"."Name", "p"."PictureUrl", "p"."Price", "p"."QuantityInStock", "p"."Type"
      FROM "Products" AS "p"
      WHERE (@__lowerCaseSearchTerm_0 = '' OR instr(lower("p"."Name"), @__lowerCaseSearchTerm_0) > 0) AND lower("p"."Brand") IN ('angular', 'react') AND lower("p"."Type") = 'gloves'
      ORDER BY "p"."Price" DESC

At this point, we added Pagination
And created classes to provide all pagination info to user.

Added Pagination Logic in previous commit.
Here, just by adding [FromQuery] Annotation,
.NET understands, to search inside query string
for the properties of object passed as argument to given function.
 ---------------------------------------------------------------------------------------------------------------------------------------------

Fetch brands and types in FrontEnd.
create a different useEffect for filterLoaded flag
Brcause, if we add in productLoaded and filtersLoaded in same useEffect
& if products are not loade before filters, we are giving multiple calss to backend, until both flags true.


At this point, we created an interface for productParams
And created reducers to set new state and reset to initial state.

At this point,
in agent.ts, we modified out GET requests to carry an optional URLSearchParams object
Which can pass any parameters to backend.
Sgape the ProductParams to URLSearchParams and send it along with request.
---------------------------------------------------------------------------------------------------------------------------------------------


